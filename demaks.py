# -*- coding: utf-8 -*-
"""demaks.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1VPWNw4RoQAHXT3zlfvGh7NXtQq3lGzV1
"""

!pip install scikit-surprise

import pandas as pd
import numpy as np
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity
from surprise import Dataset, Reader, SVD
from surprise.model_selection import train_test_split
from surprise import accuracy

# Downgrade numpy to a version compatible with scikit-surprise
!pip uninstall numpy -y
!pip install "numpy<2"

import pandas as pd
import numpy as np
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity
from surprise import Dataset, Reader, SVD
from surprise.model_selection import train_test_split
from surprise import accuracy

# Load Dataset
df = pd.read_csv("/content/TMDB_movie_dataset_v11.csv", on_bad_lines='skip', engine='python')

# Ambil bulan rilis
df['release_date'] = pd.to_datetime(df['release_date'], errors='coerce')
df['month'] = df['release_date'].dt.month

# Hitung profit margin sebagai rating
df['profit_margin'] = (df['revenue'] - df['budget']) / (df['budget'] + 1)
df['profit_margin'] = df['profit_margin'].clip(lower=-1, upper=5)  # normalisasi

# Content-Based Filtering (CBF)
df['genres'] = df['genres'].fillna('')

# TF-IDF untuk genre
tfidf = TfidfVectorizer(stop_words='english')
tfidf_matrix = tfidf.fit_transform(df['genres'])

# Cosine similarity antar film
cosine_sim = cosine_similarity(tfidf_matrix, tfidf_matrix)

# Fungsi rekomendasi CBF berdasarkan genre
def cbf_recommend(movie_title, top_n=5):
    idx = df[df['title'].str.lower() == movie_title.lower()].index[0]
    sim_scores = list(enumerate(cosine_sim[idx]))
    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)
    sim_scores = sim_scores[1:top_n+1]  # exclude film itu sendiri
    movie_indices = [i[0] for i in sim_scores]
    return df.iloc[movie_indices][['title', 'genres', 'month']]

# Collaborative Filtering (CF)
# Menggunakan bulan rilis sebagai item

reader = Reader(rating_scale=(-1, 5))
data = Dataset.load_from_df(df[['id', 'month', 'profit_margin']], reader)

trainset, testset = train_test_split(data, test_size=0.2)  # 80% train, 20% test

model = SVD()
model.fit(trainset)

predictions = model.test(testset)

# Evaluasi CF
rmse = accuracy.rmse(predictions, verbose=True)
mae = accuracy.mae(predictions, verbose=True)

# Hybrid System (CBF + CF)

def hybrid_recommend(movie_title, alpha=0.5, top_n=5):
    """
    alpha = bobot antara CBF dan CF
    """
    # Ambil skor CBF (genre similarity)
    idx = df[df['title'].str.lower() == movie_title.lower()].index[0]
    sim_scores = list(enumerate(cosine_sim[idx]))
    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)
    sim_scores = sim_scores[1:top_n+1]

    # Simpan hasil
    hybrid_results = []
    for i, sim in sim_scores:
        film_id = df.iloc[i]['id']
        bulan = int(df.iloc[i]['month'])

        # Prediksi CF (film_id, bulan)
        cf_pred = model.predict(uid=film_id, iid=bulan).est

        # Gabungan skor
        hybrid_score = alpha * sim + (1 - alpha) * cf_pred

        hybrid_results.append((df.iloc[i]['title'], bulan, sim, cf_pred, hybrid_score))

    # Ranking
    results_df = pd.DataFrame(hybrid_results, columns=['title','month','cbf_score','cf_score','hybrid_score'])
    return results_df.sort_values('hybrid_score', ascending=False).head(top_n)

!pip install mlflow

import mlflow
import mlflow.sklearn

def run_experiment(movie_title, alpha=0.6, top_n=10):
    # Cari index film
    idx = df[df['title'].str.lower() == movie_title.lower()].index[0]
    movie_genres = df.iloc[idx]['genres']

    with mlflow.start_run(run_name=f"Hybrid_Recommender_{movie_title}"):
        # Simpan parameter utama
        mlflow.log_param("movie_title", movie_title)
        mlflow.log_param("genres", movie_genres)
        mlflow.log_param("alpha", alpha)
        mlflow.log_param("top_n", top_n)

        # Simpan metrik evaluasi CF
        mlflow.log_metric("RMSE", rmse)
        mlflow.log_metric("MAE", mae)

        # Rekomendasi hybrid
        recs = hybrid_recommend(movie_title, alpha=alpha, top_n=top_n)

        # Simpan hasil rekomendasi sebagai artifact
        output_path = f"recs_{movie_title.replace(' ', '_')}.csv"
        recs.to_csv(output_path, index=False)
        mlflow.log_artifact(output_path)

        print("\n=== Rekomendasi Hybrid (CBF + CF) ===")
        print(recs)

film_list = [
    "Mad Max: Fury Road",                       # Action
    "Pirates of the Caribbean: The Curse of the Black Pearl",  # Adventure
    "Frozen",                                   # Animation
    "The Hangover",                             # Comedy
    "The Godfather",                            # Crime
    "Inside Job",                               # Documentary
    "Titanic",                                  # Drama
    "Finding Nemo",                             # Family
    "The Lord of the Rings: The Fellowship of the Ring",    # Fantasy
    "Schindler's List",                         # History
    "The Conjuring",                            # Horror
    "La La Land",                               # Music
    "Se7en",                                    # Mystery
    "The Notebook",                             # Romance
    "Inception",                                # Science Fiction
    "High School Musical",                      # TV Movie
    "The Dark Knight",                          # Thriller
    "Saving Private Ryan",                      # War
    "Django Unchained"                          # Western
]

for film in film_list:
    print(f"\n Rekomendasi CBF (berdasarkan genre) untuk '{film}'")
    try:
        print(cbf_recommend(film).head(5))
    except IndexError: # Catching IndexError specifically for movie not found
        print(f"Film '{film}' tidak ditemukan di dataset untuk CBF.")

    print("\n Evaluasi Collaborative Filtering")
    print(f"RMSE: {rmse:.4f}, MAE: {mae:.4f}")

    print(f"\n Rekomendasi Hybrid (CBF + CF) untuk '{film}'")
    # Add a check to see if the movie exists in the dataframe before calling run_experiment
    if not df[df['title'].str.lower() == film.lower()].empty:
        run_experiment(film, alpha=0.6, top_n=10)
    else:
        print(f"Film '{film}' tidak ditemukan di dataset untuk Hybrid rekomendasi.")

import matplotlib.pyplot as plt

# Daftar film & genre
film_list = [
    ("Mad Max: Fury Road", ["Action", "Adventure", "Science Fiction", "Thriller"]),
    ("Pirates of the Caribbean: The Curse of the Black Pearl", ["Adventure", "Fantasy", "Action"]),
    ("Frozen", ["Animation", "Adventure", "Family"]),
    ("The Hangover", ["Comedy"]),
    ("The Godfather", ["Crime", "Drama"]),
    ("Inside Job", ["Documentary"]),
    ("Titanic", ["Drama", "Romance"]),
    ("Finding Nemo", ["Animation", "Family"]),
    ("The Lord of the Rings: The Fellowship of the Ring", ["Adventure", "Fantasy", "Action"]),
    ("Schindler's List", ["Drama", "History", "War"]),
    ("The Conjuring", ["Horror", "Thriller"]),
    ("La La Land", ["Comedy", "Drama", "Romance", "Music"]),
    ("Se7en", ["Crime", "Mystery", "Thriller"]),
    ("The Notebook", ["Romance", "Drama"]),
    ("Inception", ["Action", "Science Fiction", "Adventure"]),
    ("High School Musical", ["Comedy", "Drama", "Family", "Music", "TV Movie"]),
    ("The Dark Knight", ["Drama", "Action", "Crime", "Thriller"]),
    ("Saving Private Ryan", ["Drama", "War", "History"]),
    ("Django Unchained", ["Drama", "Western"])
]

plt.figure(figsize=(16,8))

# Loop tiap film-genre untuk plot line hybrid score
for film, genre in film_list:
    try:
        recs = hybrid_recommend(film, alpha=0.6, top_n=10)
        scores = recs['hybrid_score'].values
        plt.plot(range(1, len(scores)+1), scores, marker="o", label=genre)
    except:
        print(f"Film '{film}' tidak ditemukan di dataset!")


plt.xticks(range(1, 11))  # pastikan 1â€“10
plt.xlim(1, 10)

# Label chart
plt.xlabel("Ranking Rekomendasi")
plt.ylabel("Hybrid Score")
plt.title("Line Chart Hybrid Score untuk Setiap Genre (19 Garis)")
plt.legend(bbox_to_anchor=(1.05, 1), loc="upper left")
plt.tight_layout()
plt.show()

from sklearn.metrics import mean_squared_error, mean_absolute_error
import numpy as np # Import numpy for sqrt

# Evaluasi Hybrid

def evaluate_hybrid(df, model, cosine_sim, alpha=0.5, top_n=5):
    """
    Evaluasi hybrid dengan menghitung error prediksi rating bulan
    dibanding profit_margin aktual.
    """
    y_true = []
    y_pred = []

    for idx in range(len(df)):
        # Skip rows where 'month' is NaN
        if pd.isna(df.iloc[idx]['month']):
            continue

        film_id = df.iloc[idx]['id']
        # Convert month to integer only after checking for NaN
        bulan = int(df.iloc[idx]['month'])
        actual_rating = df.iloc[idx]['profit_margin']

        # CBF score rata-rata similarity terhadap film lain
        sim_scores = cosine_sim[idx]
        cbf_score = np.mean(sim_scores)  # simplifikasi: bisa pakai top-N mirip

        # CF score
        try:
            cf_score = model.predict(uid=film_id, iid=bulan).est
        except:
            continue


        # Gabungan skor
        hybrid_score = alpha * cbf_score + (1 - alpha) * cf_score

        # Simpan untuk evaluasi
        y_true.append(actual_rating)
        y_pred.append(hybrid_score)

    # Hitung RMSE dan MAE
    mse_hybrid = mean_squared_error(y_true, y_pred)
    rmse_hybrid = np.sqrt(mse_hybrid) # Calculate RMSE manually
    mae_hybrid = mean_absolute_error(y_true, y_pred)

    return rmse_hybrid, mae_hybrid

# Jalankan evaluasi Hybrid
rmse_hybrid, mae_hybrid = evaluate_hybrid(df, model, cosine_sim, alpha=0.6)

print("\n Evaluasi Hybrid (CBF + CF)")
print(f"RMSE: {rmse_hybrid:.4f}")
print(f"MAE : {mae_hybrid:.4f}")